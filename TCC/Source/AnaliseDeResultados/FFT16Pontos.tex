A Tabela (\ref{tab:ResultadoSinteseFFt16}) apresenta os dados referentes ao volume de recursos utilizados pela implementação da FFT de 16 pontos na FPGA  XC7Z010-1CLG225C do kit ZynqBerry, após o processo de síntese do Vivado HLx 2017.4. 

\vspace{5mm}
\begin{table}[h]
	\centering
	\captionsetup{width=.5\linewidth}
	\begin{tabular}{|l|c|c|}
		\hline
		Recurso & Utilização & Utilização \% \\ \hline
		LUT & 5760 & 32,73 \\ \hline
		FF  & 4895 & 13,91  \\ \hline
		BRAM &  0  & 0  \\ \hline
		DSP & 0 & 0 \\ \hline 
	\end{tabular}
	\caption{Resultado de Síntese FFT 16 Pontos}
	\vspace{-3.5mm}
	\caption*{Fonte: Autoria Própria}
	\label{tab:ResultadoSinteseFFt16}
\end{table}

Em termos de consumo de recursos da FPGA, é possível fazer um paralelo dos dados entrados na bibliografia, com os obtidos pela implementação da FFT de 16 pontos. A Tabela \ref{tab:ResultadoSinteseFFt16Comparativo}  traz essa comparação.

\vspace{5mm}
\begin{table}[h]
	\centering
	\captionsetup{width=\linewidth}
	\begin{tabular}{|l|c|c|c|c|c|}
		\hline
		Referência       & LUT  & FF   & BRAM   & DSP & Wordlength(\textit{bits})\\ \hline
		Autoria Própria  & 5760 & 4895 &  0     & 0  & 16\\ \hline
		\citeonline{santhosh} & 2127 & 1572 &  0     & 14 & 9\\ \hline
	\end{tabular}
	\caption{Comparativo de Síntese - FFT 16 Pontos}
	\vspace{-3.5mm}
	\caption*{Fonte: Autoria Própria}
	\label{tab:ResultadoSinteseFFt16Comparativo}
\end{table}

Como é possível observar na Tabela (\ref{tab:ResultadoSinteseFFt16Comparativo}), o consumo de recursos da FFT implementada é o dobro da apresentada por \citeonline{santhosh}. Isso de deve principalmente ao número de \textit{bits} utilizados para representação de sinais. E também ao fato de que na FFT implementada existe 16 blocos CORDIC, os quais não são necessários em \citeonline{santhosh}, pois este utiliza blocos DSPs.

Após carregar a FPGA com o arquivo \textit{Bitstream} e programar o PS, fora enviado conjunto de sinais de entrada gerados pelo \textit{Matlab}, para a FFT implementada via interface UART do ZynqBerry. A resposta a estes sinais foi comparada com o resultado teórico, obtido pelo uso do comando \textit{fft()} do \textit{Matlab}, aplicada aos sinais gerados. A fim de mensurar o erro entre a FFT teórica, obtida no \textit{Matlab}, e a implementada, proveniente da FFT do ZynqBerry, foi utilizada a função de cálculo do SQNR (\textit{snr()}). O nível SQNR médio dos teste realizados com a FFT de 16 pontos foi de 52dB. A Tabela (\ref{tab:ResultFFT16}), apresenta um comparativo entre o nível de SQNR encontrado para esta FFT, e a vista na bibliografia.

\vspace{5mm}
\begin{table}[h]
	\centering
	\captionsetup{width=\linewidth}
	\begin{tabular}{|l|c|c|c|ll|}
		\hline
		Arquitetura & CORDIC & SQNR(dB)  & Wordlength(\text{bits}) &Referência & \\ \hline
		Radix-2     &   MSR  & 52        &    16     & Autoria Própria & \\ \hline
		Radix-4     &   -    & 40,92     &     8     & \citeonline{hassan} &  \\ \hline
		Radix-8     &   -    & 41,97     &     8     &\citeonline{hassan}  &  \\ \hline
		Radix-$2^2$ &   -    & 46        &    12     &\citeonline{saeed} & \\ \hline 
	\end{tabular}
	\caption{Comparativo Nível de SNQR para FFT de 16 Pontos}
	\vspace{-3.5mm}
	\caption*{Fonte: Autoria Própria}
	\label{tab:ResultFFT16}
\end{table}

Em comparação entre as demais FFTs apresentadas na Tabela (\ref{tab:ResultFFT16}), a principal diferença, entra a FFT implementada neste trabalho, e a vista na bibliografia, é a arquitetura utilizada. Como afirma \citeonline{Tonny}, a arquitetura Radix-4 consegue reduzir em 25\% as operações de rotações vetoriais, reduzindo os recursos consumidos da FPGA, e impactando também em um aumento de desempenho. O mesmo acontece para o Radix-8 e o Radix-$2^2$, os quais possuem arquiteturas que beneficiam a redução de recursos, e o aumento de desempenho evitando as operações de rotação.  

O desempenho da FFT aqui implementada, mesmo que possua uma melhor resolução, o que poderia justificar o bom desempenho, ainda parece se beneficiar bem do operador MSR CORDIC, atingindo assim um bom valor de SQNR. Outro ponto importante é o desempenho da FFT em termos de ciclos de \textit{clock}. Pois, nesta arquitetura a FFT de 16 pontos computa todos os dados de entrada em apenas 12 ciclos de \textit{clock}. 

Para demonstrar o desempenho da FFT de 16 pontos, a Figura (\ref{fig:SinalDeEntradaDaFFT16p}) apresenta o um sinal de entrada enviado a FFT, o qual pode ser descrita pela seguinte equação: 

\begin{eqnarray}
X_{in} = 4010 * sin(2 \pi (10) t) +12*sin(2 \pi (20)t) + \dots \\+ 520* sin(2\pi(125)t) + 230*sin(2\pi(500)t) + \dots \\ + 120*sin(2\pi(2780)t);
\end{eqnarray}

O resultado obtido pela FFT implementada é apresentada na Figura (\ref{fig:FFTResult16p}).  

\vspace{5mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.9\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.9\linewidth]{Images/ResultadosDiscussao/SinalDeEntradaDaFFT16.eps}
	\caption{Sinal com Componentes em 10Hz, 20Hz, 125Hz, 500Hz e 2780Hz}
	\vspace{-3.5mm}
	\caption*{Fonte: Simulação\textit{Matlab}}
	\label{fig:SinalDeEntradaDaFFT16p}
\end{figure}    
\vspace{5mm}


\vspace{5mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.9\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.9\linewidth]{Images/ResultadosDiscussao/FFT16pImplementada.eps}
	\caption{Espectro de Fourier proveniente da FFT de 16 Pontos}
	\vspace{-3.5mm}
	\caption*{Fonte: Autoria Própria}
	\label{fig:FFTResult16p}
\end{figure}    
\vspace{5mm}
