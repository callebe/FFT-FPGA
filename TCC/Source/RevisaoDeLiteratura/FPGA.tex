\citeonline[p.~4]{Moore} define a FPGA como um dispositivo semicondutor capaz de ser totalmente redefinido após sua fabricação, permitindo ao programador reconfigurar produtos e funções já implementadas, adaptando o \emph{hardware} a novas funções. De forma prática, a FPGA permite uma flexibilidade em um projeto, podendo mudar a forma como ele é implementado, sem a necessidade de se construir um \emph{hardware} novo. 

Para \citeonline[p.~4]{Moore}, comparado com as outras formas de construir um hardware, a FPGA oferece duas grandes vantagens em uma aplicação. Primeiro, para uma aplicação, ao invés de se utilizar um circuito integrado padrão comercial, que geralmente é  super ou subdimensionado, ou ainda desenvolver um novo projeto de circuito integrado especifico, consumindo tempo e recursos, a FPGA  possibilita desenvolver um \textit{hardware} exatamente dentro das especificações, personalizado e otimizado para a função destinada. Em segundo, porém tão importante quanto, é que essa capacidade de personalização de \textit{hardware} possibilita a realização de operações de modo mais simplificado, rápido e energeticamente eficiente se comparado a um microprocessador.

\subsection{Aspectos Construtivos da FPGA}

As FPGAs são baseadas em unidades lógicas elementares básicas, ou \sigla[Basic Logic Elements]{BLE} \textit{Basic Logic Elements}, dentro de uma hierarquia de interconexões reconfiguráveis que permitem que os BLEs sejam fisicamente conectados uns aos outros de diferentes formas, criando uma enorme variedade de componentes digitais. A arquitetura das FPGAs modernas são constituídas, basicamente, por conjunto de memórias de armazenamento em massa SRAM (\textit{Static Random Access Memory}), Portas de Entrada/Saída, blocos lógicos configuráveis  \sigla[Configurable Logic Blocks]{CLB} e sistema de roteamento, como pode ser visto na Figura (\ref{fig:FPGAArchitecture}) \cite[p.~5]{Moore}. 

\vspace{8mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.5\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.5\linewidth]{Images/RevisaoDeLiteratura/FPGAArchitecture.eps}
	\caption{Arquitetura Tipica de uma FPGA}
	\vspace{-3.5mm}
	\caption*{Fonte: Adaptado \citeonline[p.~6]{Meyer}}
	\label{fig:FPGAArchitecture}
\end{figure}
\vspace{8mm}

Os  CLB são blocos realizam operações logicas básicas e armazenam pequenos volumes de dados. Comumente as operações complexas, necessárias para o processamento de uma aplicação, são divididas em processos mais simples para cada uma das CLBs selecionadas, de modo que a soma das tarefas de cada CLB seja equivalente a operação complexa, em uma estratégia de divisão e conquista. Para realizar operações lógicas básicas e ainda armazenar pequenos volumes de dados, os CLBs tecnicamente poderiam ser apenas um pequeno circuito de transistores (granularidade fina), ou até mesmo um processador completo (granularidade grosseira). Se os CLBs fossem granularidade fina, para realizar tarefas complexas seria necessário um grande número de CLBs e um sistema de roteamento complexo para interconecta-los, o que resultaria em uma FPGA de baixo desempenho e um elevado consumo energético. Por outro lado, se as CLBs forem de uma granularidade mais grosseira, seria um desperdício de recurso utilizá-los em operações mais simples \cite[p.~11]{tree}. Assim a escolha do nível de complexabilidade, ou granulação, das CLBs de uma FPGA é um compromisso de otimização de recursos.

Segundo \citeonline[p.~11]{tree}, dentro da gama de granulação das CLBs, algumas arquiteturas incluem o uso de portas NAND, interconexão de multiplexadores e tabelas de busca LUT (\textit{Lookup Table}). Em especial, fabricantes como a Xilinx utilizam CLBs baseadas em LUTs, já que CLBs baseadas em LUT oferecem uma boa relação de granulação, otimizando os recursos da FPGA para aplicações simples até as mais complexas. Este tipo de CLB  pode incluir uma único BLE, ou mesmo um \textit{cluster} de BLEs interconectados, como mostrado na Figura (\ref{fig:ArchitectureClusterBLE}).

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.4\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.4\linewidth]{Images/RevisaoDeLiteratura/ArchitectureClusterBLE.eps}
	\caption{Arquitetura de uma CLB com 4 BLEs}
	\vspace{-3.5mm}
	\caption*{Fonte: Adaptado \citeonline[p.~13]{tree}}
	\label{fig:ArchitectureClusterBLE}
\end{figure}
\vspace{6mm}

Segundo \citeonline[p.~11]{tree}, um BLE mais simples consiste basicamente de um LUT e um \textit{Flip-Flop} tipo D, como pode ser visto na Figura (\ref{fig:BasicLogicElement}). Um LUT com $k$ entradas pode implementar $k$ funções booleanas utilizando os espaços de memória SRAM dentro da LUT. O exemplo apresentado na Figura (\ref{fig:BasicLogicElement}) utiliza  16 bits de memória SRAM, os quais são conectadas a entrada do multiplexador que possui 4 bits de seleção, e cuja saída é ligada ao \textit{flip-flop}. Esta configuração permite que a LUT tenha $2^k$ combinações das $k$ operações booleanas. 

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.5\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.5\linewidth]{Images/RevisaoDeLiteratura/BasicLogicElement.eps}
	\caption{Arquitetura de uma BLE (\textit{Basic Logic Element})}
	\vspace{-3.5mm}
	\caption*{Fonte: Adaptado \citeonline[p.~13]{tree}}
	\label{fig:BasicLogicElement}
\end{figure}
\vspace{6mm}

Um único BLE é capaz de realizar algumas operações booleanas básicas, porém em clusters as combinações de operações aumentam. FPGAs modernas tipicamente contém de 4 a 10 BLEs em um único cluster. Porém, estas FPGAs não possui apenas BLEs idênticas, na verdade há uma grande heterogenia de blocos, sendo muitos deles desenvolvidos para propósitos específicos. Entre estes blocos de propósito específico estão multiplicadores, somadores, memórias e DSPs (\textit{Digital Signal Processor}), entre outros. Estes blocos são desenvolvidos para otimizar o espaço, processamento, roteamento e demais recursos de \textit{hardware} que seriam necessários para implementar as mesmas funções em BLEs comuns, sendo essenciais em certas aplicações \citeonline[p.~10]{tree}.

A implementação de qualquer circuito lógico é feita pela associação de diferentes blocos lógicos e pelas portas de entrada e saída da FPGA, os quais são conectados uns aos outros por meio da rede de roteamento programável, ou PLN (\textit{Programmable Logic Network}). Na Figura (\ref{fig:FPGAArchitecture}) a PLN é representada pela Matriz Programável de Interconexões e pelos Canais de Roteamento. Para que a FPGA possa implementar qualquer circuito digital, as interconexões de roteamento devem ser flexíveis para suportar a grande variedade de conexões demandada, otimizando sempre as distâncias das conexões e reduzindo a latência dos sinais.  Portanto, ao projetar um circuito a ser implementado na FPGA deve ser ter especial atenção a forma como o roteamento do blocos lógicos é feito, buscando flexibilidade e eficiência \citeonline[p.~13]{tree}.

Nas FPGAs modernas, além da unidades de armazenamento de Dados SRAM contido dentro das BLEs, mais especificamente nas LUTs, existe ainda grandes blocos SRAM isolados das BLEs, destinados a funcionar como o armazenamento de dados em massa. Estes blocos são importantes em aplicações digitais onde  é necessário armazenar, como por exemplo, dados de amostragem ou mesmo dados que devem aguardar para serem passados para uma próxima etapa de processamento, ou mesmo transmitidos para fora da FPGA pelas portas de entrada e saída de dados. Estes blocos de memória é apresentada na Figura (\ref{fig:FPGAArchitecture}) como parte integrante da arquitetura tipica de uma FPGA.

\subsection{Programação na FPGA}

O desenvolvimento de uma aplicação em FPGA começa pela elaboração do Design de Referência, que nada mais é do que uma descrição lógica equivalente que deve ser programada na FPGA para implementação das operações lógicas desejadas. O Design de Referência pode ser feito utilizando diagrama de portas lógicas ou ainda usando qualquer linguagem de descrição de hardware como VHDL (\textit{VHSIC Hardware Description Language}) ou Verilog. A maioria dos ambientes de desenvolvimento integrados (IDE - \textit{Integrated Development Environment}), disponibilizados pelos fabricantes de FPGAs possuem  a opção de programação visual utilizando portas lógicas. A Figura (\ref{fig:ExemploFullAdder4Bits}) apresenta o diagrama de um somador de 4 bits, feito no IDE ISE Design Suite 14, da fabricante Xilinx. 

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=\linewidth]{Images/RevisaoDeLiteratura/ExemploFullAdder4Bits.eps}
	\caption{Diagrama Lógico Full Adder 4 Bits - ISE Design Suite 14}
	\vspace{-3.5mm}
	\caption*{Fonte: Autoria Própria}
	\label{fig:ExemploFullAdder4Bits}
\end{figure}
\vspace{6mm}

Programar um somador de 4 bits, como apresentado na Figura (\ref{fig:ExemploFullAdder4Bits}), utilizando portas lógicas parece ser realmente simples. Porém, para circuitos mais elaborados como um contador, ou até mesmo uma máquina de estados, pode ser tornar impraticável utilizar este método de desenvolvimento. Para circuitos mais elaborados é possível utilizar uma linguagem de descrição de \textit{hardware} \sigla[Hardware Description Linguage]{HDL}, para tornam o desenvolvimento mais fácil e intuitivo. Tendo em vista, que mesmo esta linguagem não ser destinada a execução por um processador, e na verdade descrever o comportamento de circuitos lógicos, ela  é visivelmente mais familiar ao desenvolvedor que está acostumado a linguagens de programação, como por exemplo Linguagem C. 

O Código VHDL (\ref{code:ExemploFullAdder4Bits}), descrito abaixo, apresenta o mesmo somador de 4 bits apresentado anteriormente em (\ref{fig:ExemploFullAdder4Bits}). 

\vspace{3mm}
	\lstset{style=VHDL}
	\begin{lstlisting}[caption={Autoria Própria},captionpos=b,mathescape]
	library IEEE;
	use IEEE.STD_LOGIC_1164.ALL;
	use IEEE.NUMERIC_STD.ALL;
	
	entity FullAdder4Bits is
		port(InputA : in unsigned(3 downto 0);
		 InputB : in unsigned(3 downto 0); 
		 Result : out unsigned(3 downto 0); 
		 CarryOut : out std_logic);
	end entity;
	
	architecture Behavioral of FullAdder4Bits is
		
		signal Aux : unsigned(4 downto 0);
		
	begin 
		
		Aux <= ("0" & InputA) + InputB; 
		Result <= temp(3 downto 0); 
		CarryOut <= Aux(4);
		
	end architecture Behavioral;
	\end{lstlisting}
	\label{code:ExemploFullAdder4Bits}
\vspace{3mm}

Após definir o Design de Referência, via diagrama de portas lógicas ou mesmo em linguagem VHDL, o próximo passo é utilizar uma ferramenta de síntese da própria IDE para converter o design de referência em um conjunto de configurações de registradores, conexões e portas que serão usadas  na FPGA para implementar as funcionalidades descritas no design de referência. Durante o processo de síntese a ferramenta verifica a sintaxe do código HDL, e a coerência entre as portas de externas, como sinais de \textit{clock} e portas de entrada e saída,  selecionadas no design de referência.

Ao desenvolver um design para implementação em FPGA é comum dividir as funcionalidades do sistema em pequenos blocos de modo a modularizá-lo, permitindo reaproveitar trechos de circuitos lógicos em diferentes aplicações. Segundo \citeonline[p.~20]{Moore} ao longo dos anos os fabricantes FPGA perceberam também que vários dos sistemas implementados pelos desenvolvedores tinham funcionalidades muito comuns, como por exemplo processamento gráfico, interfaces de comunicação serial e até mesmo implementação de microprocessadores. Logo, não fazia sentido o desenvolvedor desperdiças tempo implementando um circuito extremamente comum. Assim, os fabricantes passaram a oferecer bibliotecas circuitos lógicos modularizados para funcionalidades comuns, que passaram a ser chamados de IP (\textit{Intellectual Property}).
 
A maioria dos IDEs mais recentes possuem uma interface gráfica de diagrama de blocos, onde cada bloco representa uma IP. Nesta interface é possível construir um Design de Referência utilizando a associação de IPs das bibliotecas do fabricante, ou de um repositório externo ou ainda utilizar uma IP própria, já que estes IDEs possibilitam a criação de IPs personalizadas. A Figura (\ref{fig:ExemploDiagramaDeBlocosMicroBlazeUART}) apresenta o diagrama de blocos de um circuito lógico desenvolvido na IDE Vivado 2017.4, composto pelas seguintes IPs da Biblioteca padrão Xilinx: microprocessador MicroBlaze 10.0, bloco seu memória local, o controlador de periféricos MicroBlaze, a interface de comunicação UART, controle global de interrupções e controle de global de \textit{reset}. A IP \textit{FFT16p\_V1\_0\_0} desenvolvida individualmente utilizando código VHDL.

\begin{landscape}
	\begin{figure}[H]
		\centering
		\captionsetup{width=0.9\textwidth, font=footnotesize, textfont=bf}	
		\includegraphics[width=0.9\linewidth]{Images/RevisaoDeLiteratura/ExemploDiagramaDeBlocosMicroBlazeUART.png}
		\caption{CPU MicroBlaze e Coprocessador para FFT com Interface UART - Vivado 2017.4}
		\vspace{-3.5mm}
		\caption*{Fonte: Autoria Própria}
		\label{fig:ExemploDiagramaDeBlocosMicroBlazeUART}
	\end{figure}
\end{landscape}
 
A FPGA é uma boa escolha para a implementação do algoritmo da FFT  devido a grande variedade de recursos de \textit{hardware} sintetizáveis, além de possuir recursos de programação paralela que permite o processamento paralelo de sinais, conferindo assim uma maior rapidez na execução do algoritmo \cite{kamal}. Como afirma \citeonline[Prefácio]{Meyer}, muitos algoritmos de processamento de sinais, como FFT (\emph{Fast Fourier Transform}) e os filtros FIR ou IIR,  implementados anteriormente em Circuitos Integrados de Aplicação Especifica ou ASIC (\emph{Application Specific Integrated Circuits}), agora estão sendo implementados em FPGAs.

\subsubsection{Zynq-7000}

Segundo a \citeonline{zynqbook}, Zynq-7000 é uma família de SoCs que integram a programabilidade em \textit{software} de um processador ARM  Cortex-A9, com  a programabilidade em \textit{hardware} de uma FPGA, possibilitando a integração entre CPU, DSPs e FPGA, agregando diversas funcionalidades em um único dispositivo. Zynq-7000 representa uma solução completa em processamento de sinais em um único dispositivo, com um ótima relação performance/consumo energético.

A principal característica do Zynq-7000 é a forma com que ele combina um sistema de processamento (PS - \textit{Processing System}), formado pelo entorno do processador ARM Cortex-A9, e um sistema de lógico programável (PL - \textit{Programmable Logic}), caracterizado como um FPGA.  Processadores dedicados já tem sido utilizados em conjunto com FPGAs em diferentes aplicações, porém não da mesma forma como é feita na  familia Zynq-7000 \citeonline[Introdução]{zynqbook}.

Para \citeonline[p. 26]{zynqbook}, o PL é ideal para a implementação de operações lógicas de alta performance e sistemas de fluxo de dados contínuos. Por outro lado o PS é capaz de suportar rotinas de \textit{software} e sistemas operacionais. Qualquer aplicação pode ser particionada em duas partes a serem implementadas uma em PL e outra em PS, a fim de se tirar proveito do melhor dos dois mundos. Porém, estas duas partes, mesmo que estando contidas dentro do encapsulamento do Zynq, como pode ser visto na Figura \ref{fig:ArquiteturaSimplificadaZynq}, são fisicamente distintas, e comumente estão operando em frequências diferentes. Para realizar a ponte de comunicação entre o PL e o PS, a família Zynq-7000 utiliza o padrão industrial conhecido como AXI (\textit{Advanced eXtensible Interface}), ou interface extensível avançada. Esta interface permite estabelecer um fluxo de dados sincronizados entre PS e PL, de ambos os sentidos, suportando inclusive o disparo de interrupções através de ambos os sistemas.

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.6\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.6\linewidth]{Images/RevisaoDeLiteratura/ArquiteturaSimplificadaZynq.eps}
	\caption{Arquitetura Simplificada - Zynq-7000}
	\vspace{-3.5mm}
	\caption*{Fonte: \citeonline[p. 26]{zynqbook}}
	\label{fig:ArquiteturaSimplificadaZynq}
\end{figure}
\vspace{6mm}

Para entender como os componentes de um sistema digital são mapeados dentro de um dispositivo Zynq, e como estes são divididos entre o PS e o PL, é necessário compreender como é a arquitetura de um sistema digital comum. Para \citeonline[p. 27]{zynqbook}, o modelo básico do \textit{hardware} de um sistemas digitais incorpora processadores, memórias, barramentos de interligação e os mais distintos periféricos, como pode ser visto na Figura (\ref{fig:ArquiteturaSimplificadaSD}).

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.6\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.6\linewidth]{Images/RevisaoDeLiteratura/ArquiteturaSimplificadaSD.eps}
	\caption{Arquitetura Simplificada de um Sistema Digital}
	\vspace{-3.5mm}
	\caption*{Fonte: \citeonline[p. 27]{zynqbook}}
	\label{fig:ArquiteturaSimplificadaSD}
\end{figure}
\vspace{6mm}

O processador é o elemento central deste modelo, pois é ele que executa o sistema de \textit{software}, que compreende as camadas de mais alto nível como aplicações baseadas em sistemas operacionais, o próprio sistema operacional, e até o nível mais baixo como o \textit{firmware} de interface com os periféricos do \textit{hardware}\cite[p. 27]{zynqbook}. Já os periféricos são componentes funcionais externos ao processador, e que em geral são divididos em três tipos: 

\begin{itemize}
	
	\item \textbf{Coprocessadores :} Elementos que auxiliam o processador principal na realização de tarefas especificas, geralmente projetados para otimizar tal tarefa.
	
	\item \textbf{Interfaces de Comunicação:} Elementos responsáveis pela interação com interfaces externas, acionando gatilhos ou controlando portas digitais. Utilizando muitas vezes protocolos específicos de comunicação como UART ou SPI.
	
	\item \textbf{Elementos Adicionais de Memória :} Elementos exclusivamente destinados ao armazenamento de dados.  
	
\end{itemize} 

A Figura (\ref{fig:ArquiteturaSimplificadaZynqSoftwareHardware}) apresentam a mesma arquitetura simplificada da Figura (\ref{fig:ArquiteturaSimplificadaSD}), porém mapeado para um dispositivo Zynq. A estrutura do sistema digital é dividida entre processador e memória para o lado PS, e os demais possíveis periféricos para o lado PL. Do lado PS, a arquitetura é fixa, obedecendo a estrutura definida pelo fabricante, em total contraponto com o lado PS. No lado PS, a estrutura é totalmente flexível, limitada apenas pelo número de CLBs disponíveis na FPGA, o que oferece ao desenvolvedor um ambiente de caixa de areia para construir qualquer tipo de periférico.

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.6\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.6\linewidth]{Images/RevisaoDeLiteratura/ArquiteturaSimplificadaZynqSoftwareHardware.eps}
	\caption{Arquitetura Simplificada do um Sistema Digital Mapeado para o Zynq}
	\vspace{-3.5mm}
	\caption*{Fonte: Adaptado de \citeonline[p. 27]{zynqbook}}
	\label{fig:ArquiteturaSimplificadaZynqSoftwareHardware}
\end{figure}
\vspace{6mm}

A interface AXI possui uma grande importância no desenvolvimento no Zynq-7000, já que por meio desta interface é que os periféricos em PL se comunicam com o processador em PS.  A interface AXI faz parte da família de barramentos para microcontroladores ARM AMBA (\textit{Advanced Microcontroller Bus Architecture}). O ARM AMBA é um protocolo \textit{Open Standard} para conexões e gerenciamento de blocos funcionais dentro de dispositivos  \textit{Systens-on-Chip} (Soc), facilitando o desenvolvimento de designs com múltiplos processadores, e com grande número de controladores e periféricos \cite{AMBA}. A família de SoCs Zynq-7000 utilizam a interface AXI versão 4, o qual obedece ao mais recentes padrões ARM AMBA 4.0 \cite{AXI}.

Dentro do ambiente do PS no Zynq, além do processador ARM Cortex-A9,  existe ainda um conjunto de periféricos de memória, interconexão, comunicação e gerenciamento. A maioria destes periféricos utiliza a interface AXI, com 32 ou 64 Bits, inclusive a próprias conexões de fronteira entre PS e PL. Diferente de PS, onde a arquitetura já está pronta e é estática, em PL o desenvolvedor pode criar todo uma gama de periféricos, e consequentemente conectá-los com uma quantidade enorme de interfaces AXI de qualquer tipo dos já citados. Porém, a fronteira entre PS e PL é limitada e representa um gargalo na interação entre os dois lados. Os dispositivos da família Zynq-7000 possuem 2 interfaces AXI Mestre de 32-Bits, 2 interfaces AXI Escravo de 32-Bits e 4 interfaces 64-Bit/32-Bit configuráveis de alta velocidade. A Figura (\ref{fig:VisaoGeralArquiteturaZynq7000}) apresenta uma visão geral da arquitetura do SoC Zynq-700, mostrando as conexões AXI dentro de PS e também as conexões na fronteira de PL. 

\vspace{6mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.8\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.8\linewidth]{Images/RevisaoDeLiteratura/VisaoGeralArquiteturaZynq7000.eps}
	\caption{Visão Geral da Arquitetura - Zynq 7000}
	\vspace{-3.5mm}
	\caption*{Legenda: {\color{darkgreen}AXI 32-Bits/64-Bits}, {\color{greenblue}AXI 64-Bits}, {\color{darkred}AXI 32-Bits}, {\color{palatinatepurple}AHB 32-Bits}, {\color{blackyellow}AXI 32-Bits}}
	\vspace{-3.5mm}
	\caption*{Fonte: Adaptado de \cite{zynq-7000}}
	\label{fig:VisaoGeralArquiteturaZynq7000}
\end{figure}
\vspace{6mm}



