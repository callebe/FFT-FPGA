
Como apresentado na Seção (\ref{section:MSR-CORDIC}), a determinação dos parâmetros Cordic $\mu_i$, $\mu_j$, $s_i$, $s_j$, $I$ e $J$ da Equação (\ref{eq:MSR}) é feita com base na minimização do erro de aproximação $\upepsilon$, descrito pela Equação (\ref{eq:OtimizacaoMSR}).
Para encontrar o conjunto ótimo de parâmetros Cordic é possível utilizar uma variedade de algoritmos determinísticos, já que este sistema se assemelha a problemas clássicos de otimização. 

Na Seção (\ref{section:TBS}) fora apresentado o algoritmo de otimização TBS, o qual se destinava a determinação do conjunto de parâmetros Cordic para o EEASR. O EEASR possuí um conjunto de ângulos elementares menores do que o MSR, e a função de otimização não incluía a redução do do erro de ganho $K_c$ em relação a unidade, já que a compensação deste ganho era realizada em uma etapa independente através de uma pseudo-rotação. Porém ao se adaptar a equação de minimização do TBS para o caso do MSR, e incluir no conjunto de solução os ângulos elementares do MSR.

Segue abaixo o pseudo-código utilizado para obter o conjunto ótimo de parâmetros Cordic. O vetor $r_{\theta}$ representa o conjunto de todos ângulos elementares, e $r_p$ presenta o conjuntos dos ganhos $K_n$, ambos oriundos das diferentes combinações entre os parâmetros Cordic.

 
\vspace{3mm}
	\lstset{style=VHDL}
	\begin{lstlisting}[caption={My Caption},captionpos=b,mathescape]
		% Inicialização
		$\displaystyle \phi_{\theta}(1,k)~=~r_{\theta}(k)~para~todo~k,$
		$\displaystyle \phi_p(1,k)~=~r_p(k)~para~todo~k,$
		
		%Acumulação
		$\displaystyle FOR~i=1~to~N-1$
			$\displaystyle FOR~k=1~to~Z(S_2)$
				$\displaystyle Encontra~k'~tal~que~:$
					$\displaystyle \upepsilon ~=~ min \sqrt{(\phi_{\theta}(i,k')+r_{\theta}(k)-\theta )^2 + (\phi_p(i,k^*)*r_p(k)-1 )^2} : 1 \leq k^* \leq Z(S_3) $
				$\phi_{\theta}(i+1,k)~=~\phi_{\theta}(i,k')+r_{\theta}(k)$
				$\phi_p(i+1,k^*)~=~\phi_p(i,k^*) * r_p(k)$
			$\displaystyle END$
		$\displaystyle END$
		
		%Determinação do Ótimo Global
		$\displaystyle Encontra~k^*~tal~que~$
			$\displaystyle \upepsilon ~=~ min \sqrt{(\phi_{\theta}(N,k^*)-\theta )^2 + (\phi_p(N,k^*)-1 )^2} : 1 \leq k^* \leq Z(S_3) $
		$\displaystyle Result(N)~=~K^*$
		
		%Determinação do Caminho Solução
		$\displaystyle FOR~i=N~to~2$
			$\displaystyle Encontra~k'~tal~que~$
				$\displaystyle \upepsilon ~=~ min \sqrt{(\phi_{\theta}(i-1,k')+r_{\theta}(k)-\theta )^2 + (\phi_p(i-1,k^*)*r_p(k)-1 )^2} : 1 \leq k^* \leq Z(S_3) $
			$\displaystyle k^*=k'$
			$\displaystyle Result(i-1)=k'$
		$\displaystyle END$
	
	\end{lstlisting}
	\label{code:PCTBSAlterado}
\vspace{3mm}

Uma atenção especial é dada para o vetor de ângulos elementares $r_{\theta}$. Este vetor é preenchido com o valor de ângulos obtidos pelo conjunto de combinações possíveis dos parâmetros Cordic do MSR, através da Equação (\ref{eq:S3}), o qual é reescrita como:

\begin{eqnarray}
	\alpha = \sum_{i=1}^{I} \mu_{i}2^{-s_i (n)} \\
	\beta = \sum_{j=1}^{J} \mu_{j}2^{-s_j (n)} \\
	r_{\theta} =  tan^{-1} \left(\frac{\beta}{\alpha}\right) \\ 
	:~\mu_{i},\mu_{j} \in \{-1,0,1\} \\
	s_i,s_j \in \{0,1, \dots, S\} 
	\label{eq:S32}
\end{eqnarray}

Através das diferentes combinações de parâmetros uma variedade de possibilidades de ângulos preenchem o vetor  $r_{\theta}$. Porém há um problema com o cálculo do arco tangente para combinações onde o  $(\alpha<0, \beta<0)$ e $(\alpha>0, \beta<0)$, pois nestes casos as operações de rotação deslocariam o vetor para o 4º e  3º quadrantes respectivamente, o que deveria resultar em valores de ângulos maiores que $\pi/2$. Porém o arco tangente considera apenas valores dentro do intervalo $(-\pi/2, \pi/2)$. Para corrigir tal efeito basta aplicar a seguinte condição:

\begin{eqnarray}
	Se~\alpha<0~e~\beta<0:~~r_{\theta} =  tan^{-1} \left(\frac{\alpha}{\beta}\right) -\frac{\pi}{2} \\ 
	Se~\alpha<0~e~\beta>0:~~r_{\theta} =  tan^{-1} \left(\frac{\alpha}{\beta}\right) +\frac{\pi}{2} \\ 
\end{eqnarray}  
 
Alguns parâmetros do MSR são determinados de acordo com as limitações de complexabilidade e disponibilidade de \textit{hardware}, como é o caso do número de iterações Cordic $N$, o número de termos SPT $N_{SPT}$, e o número máximo de deslocamentos de \textit{bit} $S$. Para alguns valores fora observado a recomendação usual na literatura, em \cite{Chih}, \cite{Kuo}, \cite{Park} e \cite{Kamal}. 

O número de iteração Cordic $N$ impacta diretamente no número de ciclos de \textit{clock} necessário para realizar a operação, e também impacta no erro final $\upepsilon$. Como observado em \citeonline{Chih}, é admissível tomar $N$ como 3, e ainda obter um bom SQNR. Já o $N_{SPT}$ impacta também no desempenho do erro $\upepsilon$, mas afeta ainda a complexabilidade do \textit{hardware}, já que mais termos SPT significa mais operadores de deslocamento de \textit{bit}. Como a intenção é montar uma FFT de bom desempenho, com o maior número de pontos possível, $N_{SPT}=3$ é admissível baseado no que é visto em \citeonline{Chih}.

A escolha do número máximo de deslocamento de \textit{bits} $S$ plica na utilização de \textit{barrel shifters} maiores, e também no aumento do volume de memória necessária para guardar os conjuntos de parâmetros Cordic, para utilizar durante as operações de rotação. Quanto maior for $S$ mais liberdade é dado ao conjunto de ângulos elementares, e mais fácil é encontrar conjuntos que reduzam $\upepsilon$ dentro das restrições. 

A arquitetura da FFT implementada neste trabalho é pensada de modo que o fluxo de dados de entrada possam vir do Sistema de Processamento (PS), mas também possibilite a entrada de dados advinda de ADC (\textit{Analog-to-digital Conversor}) Flash de \textit{bits} bits. Portanto as palavras binárias utilizadas para representar os sinais precisam ter no mínimo 12 \textit{bits}.  Para evitar a ocorrência de \textit{overflow} em uma estrutura como a FFT de 1024 pontos, onde há 10 níveis, e apenas um ponto de soma a cada nível, e os ganhos são próximos da unidade, se faz necessário utilizar 16 \textit{bits} para a representação de sinais.

Logo para determinar um valor para $S$, foi implementado o Algoritmo (\label{{code:PCTBSAlterado}}) com auxilio do \textit{software} $Matlab^\circledR$. Para cada valor de $S \in \{1...16\}$ fora criado conjunto de parâmetros Cordic, fixando $I=1$ e $J=2$ (Modo Normal), para a partir destes parâmetros realizar operações de rotacionamento de vetores nos moldes da Equação (\ref{eq:MSR}). A partir destas operações de rotacionamento fora obtido o SQNR para cada valor de $S$, afim de medir o impacto que este parâmetro tem no desempenho do algoritmo. O resultado deste teste é expresso na Figura (\ref{fig:DeterminacaoS}).

\vspace{5mm}
\begin{figure}[H]
	\centering
	\captionsetup{width=0.9\textwidth, font=footnotesize, textfont=bf}	
	\includegraphics[width=0.9\linewidth]{Images/ImplementandoCordic/DeterminacaoS.eps}
	\caption{Relação entre $S$ e o SQNR Médio para MSR Cordic Modo Normal}
	\vspace{-3.5mm}
	\caption*{Fonte: Autoria Própria}
	\label{fig:DeterminacaoS}
\end{figure}    
\vspace{5mm}

Os conjuntos parâmetros $s_i$ e $s_j$ para cada iteração do algoritmo  serão armazenados em uma ROM de controle de cada Unidade Cordic. O número de \textit{bits} necessários para armazenar estes parâmetros é dado por $log(S)$. Como visto na Figura (\ref{fig:DeterminacaoS}) escolher $S=8$ promove um desempenho SQNR de $50dB$, e se faz necessário armazenar apenas $3$ \textit{bits} para cada elemento $s_i$ ou $s_j$. Porém ao utilizar $4$ \textit{bits} para os mesmo fins é possível fazer $S=16$, e alcançar um desempenho médio de $70dB$. Logo toma-se $S=16$ afim de alcançar o máximo desempenho possível.

Com citado na Seção (\ref{section:AnaliseDoErro}) os parâmetros $I$ e $J$ podem ser constantes independente da operação de rotação (Modo Normal), ou este podem variar a cada iteração (Modo Generalizado). Com base no mesmo algoritmo implementado em $Matlab^\circledR$ apresentado anteriormente, foi incluído no vetor de ângulos elementares $r$ as combinações de parâmetros possíveis quanto tomado $N_{spt}=4$, para $(I=0,J=3)$,$(I=1,J=2)$, $(I=2,J=1)$ e $(I=3,J=0)$. E então foram gerados os ó conjuntos ótimos de parâmetros Cordic. 

O Modo Generalizado, para a simulação proposta, apresentou um valor de SQNR de 92.9786 dB. O Modo Normal para o mesmo método de simulação apresentou um valor de 83.9786 dB. 

Segundo \cite{Chih}, para armazenar os parâmetros $\{\mu_{i}, \mu_{j}\} \in \{-1,0, 1\}$, $\{s_i,s_j\} \in \{0,1,..,6\}$ de uma única interação do Algoritmo MSR Cordic, são necessários $(log(S)+2)N_{SPT}$ \textit{bits} para o modo Normalizado e $(log(S)+3)N_{SPT}$ para o Modo Generalizado. Ou seja o impacto do inserção dos \textit{switches}, necessários no caso do Modo Generalizado, em termos de implementação é apenas a inclusão de mais um \text{bit} no conjunto de dados de cada interação. Justificando portanto a escolha da implementação do MSR Cordic no Modo Generalizado.

Assim os dados referente aos parâmetros escolhidos com base no Algoritmo (\ref{code:PCTBSAlterado}), para o MSR Cordic Modo Generalizado, com $N_{SPT}=3$ e $S=16$, são armazenados na forma binário em uma componente ROM em VHDL. Esta ROM é presente e individual a cada unidade Cordic. 